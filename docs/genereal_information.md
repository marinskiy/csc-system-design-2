## Общие сведения о системе

### Назначение системы 
Компьютерная игра в стиле roguelike с консольной графикой. 

### Границы системы (Scope)
* Игра является десктопным приложением. Создание мобильных клиентов не предусмотрено.
* Игра явлется однопользовательсокй и не подразумевает сетевого взаимодействия.
* В систему не входит редактор уровней а также сами уровни.

### Контекст
Игра запускается на ПК игроков. 

## Architectural drivers

### Технические ограничения
* Поддержка операционных системам Windows, Linux, MacOS.

### Бизнес ограничения
 * Команда проекта состоит из 4 программистов. В команде нет специалистов по графике, левел-дизайну и балансу.
 * Сдача первой итерации проекта 18 апреля 2022
 * В дальнейшем будут появляться новые требования, которые надо будет реализовать в рамках этой кодовой базы.

### Качественные характеристики системы
* Расширяемость. Не все требования к игре известны на момент создания архитектуры. Архитектура должна предумсатривать возможность добавления новых режимов, объектов и механик в игру.
* Сопровождаемость. Система должна быть разделена на компоненты. Имена типов, переменных, классов, функций, методов и т.д. должны информировать нас о том, что представляет собой именованный объект. 
* Надежность. В игре не должно быть крашей.
* Удобство использования. Система должна быть спроектирована таким образом, чтобы игроки, незнакомые с игрой, быстро и интуитивно могли её освоить. Для этого следует где это возможно использовать команды, общепринятые для игр этого жанра, а также подсказки.
* Безопасность. Игра не должна хранить персональных данных пользователя и другой чувствительной информации.
* Производительность. Игра должна откликаться на команды пользователя без видимой глазу задержки на устройствах на которых можно устнановить операционные системы Windows, Linux или MacOS версий выпущенных после 2010 года. 

### Функциональные требования
* Карта. В игре должна быть карта. Карта обычно генерируется, но для некоторых уровней загружается из файла. 
* Игрок. В игре должен быть персонаж игрока, способный перемещаться по карте, управляемый с клавиатуры. У игрока есть характеристики (здоровье, сила атаки).
* Инвентарь. У персонажа есть инвентарь, состоящий из вещей, которые он носит с собой. Вещи из инвентаря можно надеть и снять, надетые вещи влияют на характеристики персонажа. Вещи изначально находятся на карте, их можно поднять, чтобы добавить в инвентарь. Снятые вещи находятся в инвентаре, их можно надеть в дальнейшем;
* В игре используется консольная графика.
## Cтруктура приложения
### Взаимодействие с игроком (User Interface)
Взаимодействие с игроком реализуется двумя классами: 
* KeyboardInterpreter, который получает от пользователя начальные настройки (Settings) (например, имя файла, из которого нужно загрузить карту) и команды управления (Key) и передает их в Game Engine, 
* и Drawer, который отображает в консоль игровой мир, получая набор компонент для отображения, каждая из которых реализует интерфейс Drawable. У каждой компоненты есть метод Draw(), который её отображает и приоритет GetPriority(), который определяет порядок отображения. 

### Состояние игрового мира
Описывается классом GameState, который содержит в себе поля:
* игровой персонаж (PlayerCharacter),
* его инвентарь (Inventory),
* игровое окружение (Environment),
* текущий режим управления игрой (Mode).

Режим определяет действия, которые соответствуют нажатию определенных клавиш. Сейчас режима 2: режим карты и инвентаря. 

Игровое окружение состоит из карты и объектов на ней. Объекты представлены классом MapObject и сейчас бывают 3-х видов (классы - наследники MapObject): препятствие (Obstacle), игровой персонаж (PlayerCharacter) и сокровище (Treasure). У каждого объекта есть уникальный ObjectId, который состоит из его типа (ObjectType) и уникального идентификатора. Карта представлена классом Map, который инкапсулирует управление расположением объектов. Она состоит из клеток (MapCell), каждая из которых может содержать произвольное число объектов (клетка хранит ObjectId объектов, находящихся в ней) и позволяет:
* передвинуть или создать новый объект MoveTo(ObjectId, MapCoordinates),
* получить расположение объекта GetCoordinates(ObjectId),
* получить список объектов в данной клетке GetObjects(MapCoordinates),
* удалить объект RemoveObject(ObjectId).

Map поддерживает инварианты:
* у всех объектов на карте уникальные ObjectId,
* уже присутствующие на карте объекты перемещаются только в соседние свободные клетки (без Obstacle),
* новые объекты помещаются только на свободные клетки.
Map и все наследники MapObject реализуют интерфейс Drawable.

Инвентарь предназначен для управления предметами, уже полученными персонажем. Предмет (Treasure) обладает названием и состоянием: надет он в данный момент или нет. Инвертарь хранит набор предметов персонажа и состояние  - выбранный в данный момент предмет. Он также реализует интерфейс Drawable.

PlayerCharacter и Treasure хранят поле Stats - свои характеристики, причем характеристики Treasure - модификаторы характеристик персонажа, если персонаж надевает предмет. Инвентарь позволяет получить полные модификаторы характеристик персонажа по всем надетым предметам в методе GetAdditionalStats().

### Создание игрового мира
Реализуется классом Preprocessor в методе Create(). Он использует для создания
* карты и объектов на ней (Environment) - класс EnvironmentCreator, который поддерживает случайную генерацию карты и получение её из данного через Settings файла,
* игрового персонажа (PlayerCharacter) - класс CharacterCreator, который задает начальное состояние персонажа.

В результате Create() возвращает начальное состояние игрового мира GameState.

### Ход игры
Ход реализуется классом GameLoop в методе RunGameTurn, который:
* получает команду (Key) игрока и текущее состояние игрового мира
* в зависимости от текущего Mode, создает MapModeActionFactory или InventoryModeActionFactory
* в зависимости от команды полученной фабрикой создает экземпляр Action, который соответствует этой команде
* исполняет эту команду, меняя состояние игры
* возвращает новое состояние игры

В режиме карты поддерживаются команды:
* движение персонажа на свободную соседнюю клетку (MovePlayerRight, MovePlayerLeft, MovePlayerUp, MovePlayerDown),
* взять предмет, лежащий на одной клетке с персонажем (TakeTreasure),
* перейти в режим инвентаря (SwitchToInventory),
* выйти (Exit).

В режиме инвентаря поддерживаются команды:
* выбрать следующий предмет в списке (SelectNext),
* выбрать предыдущий предмет в списке (SelectPrevious),
* изменить состояние текущего предмета (PutOn, PutOff),
* перейти в режим карты (SwitchToMap).

### Полный игровой процесс
Игра выполняется в методе Run класса Main. Этот метод
* получает от KeyboardInterpreter начальные настройки из метода GetInitialSettings()
* передает полученные настройки в метод Create() класса Preprocessor() и получает оттуда начальный GameState
* пока игровой персонаж жив (его здоровье > 0) и игрок не завершил игру:
1. получает от KeyboardInterpreter его команды из GetNextKey() 
2. запускает RunGameTurn с текущим состоянием мира и этой командой и получает в результате следующее состояние
3. генерирует из GameState набор элементов для отображение (Map, MapObjects, Inventory) и передает их в метод Draw класса Drawer для отображения
